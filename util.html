<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<title>Lab: Xv6 and Unix utilities</title>
<link rel="stylesheet" href="https://pdos.csail.mit.edu/6.S081/2025/labs/labs.css" type="text/css">
</head>

<body bgcolor="#ffffff" text="#000000" style="">
<h1>Lab: Xv6 and Unix utilities</h1>

<p>This lab will familiarize you with xv6 and its system calls.

</p><h2>Boot xv6 (<a class="easy" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">easy</a>)</h2>

<p>
Have a look at the
<a href="https://pdos.csail.mit.edu/6.828/2025/tools.html">lab tools page</a> for information
about how to set up your computer to run these labs.

</p><p>Fetch the git repository for the xv6 source for the lab:
</p><pre>$ <kbd>git clone git://g.csail.mit.edu/xv6-labs-2025</kbd>
Cloning into 'xv6-labs-2025'...
...
$ <kbd>cd xv6-labs-2025</kbd>
</pre>

<p>The files you will need for this and subsequent labs
are distributed using
the <a href="http://www.git-scm.com/">Git</a> version control system.
For each of the labs you will check out
a version of xv6 tailored for that lab.
To learn more about Git, take a look at the
<a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">Git
user's manual</a>, or this
<a href="http://eagain.net/articles/git-for-computer-scientists/">CS-oriented
overview of Git</a>.
Git allows you to keep track of the changes you make to the code.
For example, if you are finished with one of the exercises, and want
to checkpoint your progress, you can <i>commit</i> your changes
by running:
</p>
<pre>$ <kbd>git commit -am 'my solution for util lab exercise 1'</kbd>
Created commit 60d2135: my solution for util lab exercise 1
 1 files changed, 1 insertions(+), 0 deletions(-)
$
</pre>

<p>
You can view your changes with <kbd>git diff</kbd>,
which displays changes
since your last commit. <kbd>git diff
origin/util</kbd> displays changes relative to the
initial <tt>util</tt> code.  <tt>origin/util</tt> is the
name of the git branch for this lab.
</p>

<p>Build and run xv6:
</p><pre>$ <kbd>make qemu</kbd>
riscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.S
riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c
...
riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.o
riscv64-unknown-elf-objdump -S user/_zombie &gt; user/zombie.asm
riscv64-unknown-elf-objdump -t user/_zombie | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' &gt; user/zombie.sym
mkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie
nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000
balloc: first 591 blocks have been allocated
balloc: write bitmap block at sector 45
qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0

xv6 kernel is booting

hart 2 starting
hart 1 starting
init: starting sh
$
</pre>

<p>
If you type <tt>ls</tt> at the prompt, you should see output similar
to the following:
</p><pre>$ <kbd>ls</kbd>
.              1 1 1024
..             1 1 1024
README         2 2 2227
xargstest.sh   2 3 93
cat            2 4 32864
echo           2 5 31720
forktest       2 6 15856
grep           2 7 36240
init           2 8 32216
kill           2 9 31680
ln             2 10 31504
ls             2 11 34808
mkdir          2 12 31736
rm             2 13 31720
sh             2 14 54168
stressfs       2 15 32608
usertests      2 16 178800
grind          2 17 47528
wc             2 18 33816
zombie         2 19 31080
console        3 20 0
</pre>
These are the files that <tt>mkfs</tt> includes in the
initial file system; most are programs you can run.  You just ran one of them: <tt>ls</tt>.

<p>xv6 has no <tt>ps</tt> command, but, if you type <kbd>Ctrl-p</kbd>,
the kernel will print information about each process.
If you try it now, you'll see two lines: one for <tt>init</tt>,
and one for <tt>sh</tt>.

</p><p>To quit qemu type: <kbd>Ctrl-a x</kbd> (press <kbd>Ctrl</kbd> and <kbd>a</kbd> at the same time, followed by <kbd>x</kbd>).

</p><h2>sleep (<a class="easy" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">easy</a>)</h2>

<p>This exercise makes you familiar with writing a user program on xv6
  and the <tt>pause</tt> system call.

</p><div class="lab-required">
<p>Implement a user-level <tt>sleep</tt> program for xv6, along the lines
  of the UNIX sleep command. Your <tt>sleep</tt> should pause
  for a user-specified number of ticks.  A tick is a notion of time
  defined by the xv6 kernel, namely the time between two interrupts
  from the timer chip.  Your solution should be in the file
  <tt>user/sleep.c</tt>.
</p></div>

<p>

</p><p>Some hints:
  </p><ul>

    <li>Before you start coding, read Chapter 1 of
    the <a href="https://pdos.csail.mit.edu/6.828/2025/xv6/book-riscv-rev5.pdf">xv6 book</a>.

    </li><li>Put your code in <tt>user/sleep.c</tt>.
    Look at some of the other programs in <tt>user/</tt>
    (e.g., <tt>user/echo.c</tt>, <tt>user/grep.c</tt>,
    and <tt>user/rm.c</tt>)
    to see how command-line arguments are passed to a program.

    </li><li>Add your <tt>sleep</tt> program to <tt>UPROGS</tt> in Makefile; once you've
    done that, <tt>make qemu</tt> will compile your program and you'll
    be able to run it from the xv6 shell.

    </li><li>If the user
    forgets to pass an argument, sleep should print an error message.

    </li><li>The command-line argument is passed as a string; you can convert it to an
      integer using <tt>atoi</tt> (see user/ulib.c).

    </li><li>Use the system call <tt>pause()</tt>.

    </li><li>See <tt>kernel/sysproc.c</tt> for
    the xv6 kernel code that implements the <tt>pause()</tt> system
    call (look for <tt>sys_pause</tt>), <tt>user/user.h</tt>
    for the C definition of <tt>pause()</tt> callable from a
    user program, and <tt>user/usys.S</tt> for the assembler
    code that jumps from user code into the kernel for <tt>pause()</tt>.

    </li><li>Look at Kernighan and Ritchie's book <i>The C programming language
        (second edition)</i> (K&amp;R) to learn about C.

  </li></ul>

  <p>Run the program from the xv6 shell:
    </p><pre>      $ <kbd>make qemu</kbd>
      ...
      init: starting sh
      $ <kbd>sleep 10</kbd>
      (nothing happens for a little while)
      $
    </pre>
  <p>Your program should pause when
  run as shown above.
  Run <kbd>make grade</kbd> in your command line (outside of qemu) to see if you pass the
    sleep tests.

 </p><p>Note that <kbd>make grade</kbd> runs all tests, including the ones for the 
 tasks below. If you want to run the grade tests for one task, type:
   </p><pre>     $ <kbd>./grade-lab-util sleep</kbd>
   </pre>
   This will run the grade tests that match "sleep".  Or, you can type:
   <pre>     $ <kbd>make GRADEFLAGS=sleep grade</kbd>
   </pre>
   which does the same.

<h2>sixfive (<a class="moderate" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">moderate</a>)</h2>

 <p>In this exercise you'll use the system calls open and read, C
   strings, and processing text files in C.

</p><div class="lab-required">
  <p>For each input file, <tt>sixfive</tt> must print all the numbers
    in the file that are multiples of 5 or 6.  Number are a sequence of
    decimal digits separated by characters in the string " -\r\t\n./,".  Thus,
    for the six in "xv6" sixfive shouldn't print 6 but, for example,
    "/6," it should.
</p></div>

  The following example illustrates sixfive's behavior:
  <pre>    $ <kbd>sixfive sixfive.txt</kbd>
    5
    100
    18
    6
    $
  </pre>

<p>Some hints:
  </p><ul>
    <li>Read the input file a character at the time
    </li><li> You can test if a character matches any of the separators
    using <tt>strchr</tt> (see user/ulib.c).
    </li><li>Start and end of file are implicit separators.
  </li></ul>

<h2>memdump (<a class="easy" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">easy</a>)</h2>

<p>
  This exercise will give you more practice using C pointers.  Before
  starting read section 5.1 (Pointers and addresses) through 5.6
  (Pointer arrays) and 6.4 (pointers to structures) in "The C
  programming language (second edition)" by Kernighan and Ritchie
  (K&amp;R).

</p><p>
Have a look at <tt>user/memdump.c</tt>. Your job is to implement the function
<tt>memdump(char *fmt, char *data)</tt>. <tt>memdump()</tt>'s purpose is to print the
contents of the memory pointed to by data in the format described by
the fmt argument. The format is a C string. Each character of the
string indicates how to print successive parts of the data. Thus, for
example, a C struct with multiple fields can be printed with a format
string containing multiple characters.

</p><p>
Your memdump() should handle the following format characters:

</p><ul>
<li>i: print the next 4 bytes of the data as a 32-bit integer, in decimal.
</li><li>p: print the next 8 bytes of the data as a 64-bit integer, in hex.
</li><li>h: print the next 2 bytes of the data as a 16-bit integer, in decimal.
</li><li>c: print the next 1 byte of the data as an 8-bit ASCII character.
</li><li>s: the next 8 bytes of the data contain a 64-bit pointer to a C
   string; print the string.
</li><li>S: the rest of the data contains the bytes of a null-terminated
   C string; print the string.
</li></ul>

<p>
Feel free to use C's <tt>printf()</tt> in your <tt>memdump()</tt>.

</p><p>
The <tt>memdump</tt> program, if executed with no arguments, calls <tt>memdump()</tt>
with some example format strings and data. If <tt>memdump()</tt> is correctly
implemented, the output will be:

</p><pre>$ memdump
Example 1:
61810
2025
Example 2:
a string
Example 3:
another
Example 4:
BD0
1819438967
100
z
xyzzy
Example 5:
hello
w
o
r
l
d
</pre>

<p>
You will likely get a different hex address for the first line
of the Example 4 output.

</p><p>
If the <tt>memdump</tt> program is invoked with an argument, it will read
its standard input up to an end of file, and then call <tt>memdump()</tt>
with the format and input data. So, once <tt>memdump()</tt> is implemented:

</p><pre>$ echo deadc0de | memdump hhcccc
25956
25697
c
0
d
e
$ echo deadc0de | memdump p
64616564
$ 
</pre>

<div class="lab-required">
  <p>Implement <tt>memdump()</tt>.
</p></div>

<h2>find (<a class="moderate" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">moderate</a>)</h2>

<p>This exercise explores pathnames and directories, and the
  system calls open, read, and fstat.

</p><div class="lab-required">
<p>Write a simple version of the UNIX find program for xv6: find all the files
  in a directory tree with a specific name.  Your solution
  should be in the file <tt>user/find.c</tt>.

</p></div>

<p>Some hints:
  </p><ul>
    <li>Look at user/ls.c to see how to read a directory.
    </li><li>Use recursion to allow find to descend into sub-directories.
    </li><li>Don't recurse into "." and "..".
    </li><li>Each time you invoke <kbd>make qemu</kbd>, it will build a new
      fs.img, removing files created in a previous run. If you would
      like to start qemu with the file system from a previous
      use <kbd>make qemu-fs</kbd>.
    </li><li>You'll need to use C strings. Have a look at K&amp;R (the C book),
      for example Section 5.5.
    </li><li> Note that == does not compare strings as in Python. Use strcmp() instead.
    </li><li>Add the program to <tt>UPROGS</tt> in Makefile.
  </li></ul>

<p>Your solution should produce the following output (when the
  file system contains the files <tt>b</tt>, <tt>a/b</tt> and <tt>a/aa/b</tt>):
  </p><pre>    $ <kbd>make qemu</kbd>
    ...
    init: starting sh
    $ <kbd>echo &gt; b</kbd>
    $ <kbd>mkdir a</kbd>
    $ <kbd>echo &gt; a/b</kbd>
    $ <kbd>mkdir a/aa</kbd>
    $ <kbd>echo &gt; a/aa/b</kbd>
    $ <kbd>find . b</kbd>
    ./b
    ./a/b
    ./a/aa/b
    $
  </pre>

<p>Run <tt>make grade</tt> to see what our tests think.

</p><h2>exec (<a class="moderate" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">moderate</a>)</h2>

<p>This exercise involves the system calls fork, exec, and wait.

</p><div class="lab-required">
  <p>Add a "-exec <i>cmd</i>" to <tt>find</tt>, which executes the program "<tt>cmd file</tt>"
	for each file <i>f</i> that <tt>find</tt> finds,
  instead of printing matching file names.
</p></div>

  The following example illustrates find -exec
  behavior:
  <pre>    $ <kbd>find . wc -exec echo hi</kbd>
    hi ./wc
    $
  </pre>
  Note that the command here is "echo hi" and the file
  is "./wc", making the command "echo hi ./wc",
  which outputs "hi ./wc".

<p>Some hints:
  </p><ul>
    <li>Use <tt>fork</tt> and <tt>exec</tt> to invoke the
      command on each file.  Use <tt>wait</tt> in the parent
      to wait for the child to complete the command.
    </li><li>kernel/param.h declares MAXARG, which may be useful if you need
      to declare an argv array.
  </li></ul>

<p>To test your solution for find, run the shell script findtest.sh.
Your solution should produce the following output:
  </p><pre>  $ <kbd>make qemu</kbd>
  ...
  init: starting sh
  $ <kbd>sh &lt; findtest.sh</kbd>
$ echo DONE
$ $ $ $ $ hello
hello
hello
$ $
  </pre>
The output has
many <tt>$</tt> because the xv6 shell doesn't realize
it is processing commands from a file instead of from the console, and
prints a <tt>$</tt> for each command in the file.

<!-- START SECTION: submit -->
<p><a name="submit"></a>
</p><h2>Submit the lab</h2>

<h3>Time spent</h3>

<p>Create a new file, <tt>time.txt</tt>, and put in a single integer, the
number of hours you spent on the lab.
<kbd>git add</kbd> and <kbd>git commit</kbd> the file.

</p><h3>Answers</h3>

<p>If this lab had questions, write up your answers in <tt>answers-*.txt</tt>.
<kbd>git add</kbd> and <kbd>git commit</kbd> these files.

</p><h3>Submit</h3>

<p>Assignment submissions are handled by Gradescope.
You will need an MIT gradescope account.
See Piazza for the entry code to join the class.
Use <a href="https://help.gradescope.com/article/gi7gm49peg-student-add-course#joining_a_course_using_a_course_code">this link</a>
if you need more help joining.

</p><p>When you're ready to submit, run <kbd>make zipball</kbd>,
which will generate <tt>lab.zip</tt>.
Upload this zip file to the corresponding Gradescope assignment.

</p><p> If you run <kbd>make zipball</kbd> and you have either uncomitted changes or
untracked files, you will see output similar to the following:
</p><pre> M hello.c
?? bar.c
?? foo.pyc
Untracked files will not be handed in.  Continue? [y/N]
</pre>
Inspect the above lines and make sure all files that your lab solution needs
are tracked, i.e., not listed in a line that begins with <tt>??</tt>.
You can cause <tt>git</tt> to track a new file that you create using
<kbd>git add {filename}</kbd>.
<p></p>

<p>
</p><div class="warning">
<ul>
  <li>Please run <kbd>make grade</kbd> to ensure that your code passes all of the tests.
    The Gradescope autograder will use the same grading program to assign your submission a grade.</li>
  <li>Commit any modified source code before running <kbd>make zipball</kbd>.</li>
  <li>You can inspect the status of your submission and download the submitted
    code at Gradescope. The Gradescope lab grade is your final lab grade.</li>
</ul>
</div>

<!-- END SECTION: submit -->

<h2>Optional challenge exercises</h2>

<ul>

  <li><p>Write an uptime program that prints the uptime in terms of
      ticks using the <tt>uptime</tt> system call. (<a class="easy" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">easy</a>)
      </p></li>

  <li><p>Support regular expressions in name matching
  for <tt>find</tt>.  <tt>grep.c</tt> has some primitive support for
  regular expressions.  (<a class="easy" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">easy</a>)
      </p></li>

  <li><p>The xv6 shell (<tt>user/sh.c</tt>) is just another user
      program. It lacks
      many features found in real shells, but you can modify
      and improve it. For example, modify the shell
      to not print a <tt>$</tt> when processing shell commands from a
      file (<a class="moderate" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">moderate</a>), modify the shell to
      support wait (<a class="easy" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">easy</a>),
      modify the shell to support
      tab completion (<a class="easy" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">easy</a>), modify the shell to
      keep a history of passed shell commands
      (<a class="moderate" href="https://pdos.csail.mit.edu/6.828/2025/labs/guidance.html">moderate</a>), or anything else you would
      like your shell to do. (If you are very ambitious, you may have
      to modify the kernel to support the kernel features you need;
      xv6 doesn't support much.)

</p></li></ul>
<!-- END SECTION: body -->





</body></html>
